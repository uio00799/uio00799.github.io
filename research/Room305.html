<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROOM 305 — Network MiniGame (Cartoon • HARD MODE)</title>
<style>
  :root{
    --bg1:#fff4d6; --bg2:#e6f8ff; --ink:#18222f;
    --primary:#ff7aa2; --secondary:#7adcf5; --accent:#ffd166;
    --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444; --card:#ffffff;
    --muted:#94a3b8;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-rounded, "Baloo 2", "Noto Sans Thai", "Sarabun", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:var(--ink);
    background:
      radial-gradient(1200px 600px at 15% 10%, #fff 0%, transparent 60%),
      radial-gradient(1200px 600px at 85% 0%, #fff 0%, transparent 60%),
      linear-gradient(135deg, var(--bg1), var(--bg2));
    min-height:100vh; overflow-x:hidden; padding:20px;
  }
  .container{ max-width:1200px; margin:0 auto }
  .title{ display:flex; align-items:center; justify-content:center; gap:12px; flex-wrap:wrap }
  .logo{ width:58px;height:58px;border-radius:50%;
    background:conic-gradient(from 0deg,var(--primary),var(--secondary),var(--accent),var(--primary));
    box-shadow:0 8px 0 #0001,inset 0 0 12px #fff9; position:relative; animation:spin 6s linear infinite;
  }
  .logo::after{ content:""; position:absolute; inset:10px; border-radius:50%; background:radial-gradient(#fff7,#0000 60%)}
  @keyframes spin{to{transform:rotate(360deg)}}
  h1{ margin:0; font-size:clamp(26px,3.2vw,40px); text-align:center; text-shadow:0 4px 0 #0001 }
  .ribbon{ background:linear-gradient(90deg,var(--secondary),var(--primary)); color:#fff; padding:6px 14px; border-radius:999px; font-weight:800; display:inline-block; animation:floaty 3s ease-in-out infinite }
  @keyframes floaty{0%,100%{transform:translateY(0)}50%{transform:translateY(-4px)}}
  .row{ display:grid; gap:16px } @media(min-width:900px){ .row{ grid-template-columns:1.25fr 1fr } }
  .card{ background:var(--card); border:3px solid #00000010; border-radius:18px; padding:16px; box-shadow:0 10px 0 #00000012,0 20px 30px #0000000e }
  .btn{ appearance:none;border:none;cursor:pointer;padding:12px 16px;border-radius:14px;font-weight:800;font-size:16px;background:var(--secondary);box-shadow:0 6px 0 #0c4a6e22; transition:transform .05s }
  .btn:active{ transform:translateY(2px) }
  .btn.primary{ background:var(--primary); color:#fff }
  .btn.warn{ background:var(--warn); color:#fff }
  .btn.ok{ background:var(--ok); color:#fff }
  .btn.ghost{ background:#f3f4f6 }
  .pill{ display:inline-block; padding:6px 10px; border-radius:999px; background:#f1f5f9; font-weight:800; margin:4px 6px 0 0 }
  .bar{ background:#eef2f7; height:14px; border-radius:999px; overflow:hidden }
  .bar>span{ position:relative; display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--primary),var(--secondary)) }
  .stage{ border:2px dashed #00000020; border-radius:16px; padding:12px; margin-top:12px }
  .stage.done{ border-color:#22c55e; background:#ecfdf5 }
  .grid{ display:grid; gap:12px }
  .grid.cols-2{ grid-template-columns:1fr 1fr }
  .grid.cols-3{ grid-template-columns:repeat(3,1fr) }
  .kv{ display:flex; align-items:center; gap:8px; margin:6px 0; flex-wrap:wrap }
  select,input[type="number"],input[type="text"]{
    padding:10px 12px; border:2px solid #00000020; border-radius:12px; font-weight:700; width:100%;
  }
  table{ width:100%; border-collapse:separate; border-spacing:0 8px }
  th,td{ text-align:left; padding:8px 10px; background:#fafafa; border:2px solid #00000010 }
  th{ background:#fff3; font-weight:900 }
  .badge{ font-weight:900 }
  /* Canvas */
  #netCanvas{ width:100%; height:320px; background:#fff; border:3px solid #00000010; border-radius:14px }
  /* Modal & Toast */
  .backdrop{ position:fixed; inset:0; background:#0008; display:none; align-items:center; justify-content:center; z-index:50 }
  .backdrop.show{ display:flex; animation:fade .2s ease both }
  @keyframes fade{from{opacity:0}to{opacity:1}}
  .toast{ position:fixed; right:16px; bottom:16px; background:#111827; color:#fff; padding:12px 14px; border-radius:12px; display:none; z-index:60; box-shadow:0 12px 24px #0003 }
  .toast.show{ display:block; animation:slidein .2s ease both }
  @keyframes slidein{from{transform:translateY(8px);opacity:0}to{transform:translateY(0);opacity:1}}
  /* Confetti */
  .confetti{ position:fixed; inset:0; pointer-events:none; z-index:70 }
</style>
</head>
<body>
<div class="container">
  <div class="title">
    <div class="logo" aria-hidden="true"></div>
    <h1>ROOM 305 — Network MiniGame <span class="ribbon">Cartoon • HARD MODE</span></h1>
  </div>

  <div class="row">
    <!-- LEFT: GAME -->
    <section class="card" id="game">
      <div class="kv">
        <button class="btn primary" id="btnStart">เริ่มเกม</button>
        <button class="btn" id="btnHow">สอนเล่น</button>
        <button class="btn ghost" id="btnHintNow">ใบ้ตอนนี้</button>
        <button class="btn warn" id="btnReset">รีเซ็ต</button>
        <span class="pill">ความคืบหน้า: <b id="progressText">0/3</b></span>
      </div>
      <div class="bar" aria-label="ความคืบหน้าด่าน"><span id="barFill"></span></div>

      <!-- Stage A: VLSM -->
      <div class="stage" id="sA">
        <h3>ด่าน A — VLSM จริงจัง</h3>
        <p>เครือข่ายตั้งต้น: <b>10.10.0.0/24</b> ให้แบ่งย่อยสำหรับแผนก 3 กลุ่ม <i>(ใช้ VLSM ไม่ชนกัน)</i></p>
        <div class="grid cols-3">
          <div class="card">
            <b>Dept A (≥60 hosts)</b>
            <div class="kv"><span class="badge">CIDR</span>
              <select id="aCidr"><option>/25</option><option>/26</option><option>/27</option><option>/28</option></select>
            </div>
            <div class="kv"><span class="badge">Usable</span><input id="aUsable" type="number" min="0" placeholder="ระบุจำนวน usable"/></div>
          </div>
          <div class="card">
            <b>Dept B (≥30 hosts)</b>
            <div class="kv"><span class="badge">CIDR</span>
              <select id="bCidr"><option>/25</option><option>/26</option><option>/27</option><option>/28</option></select>
            </div>
            <div class="kv"><span class="badge">Usable</span><input id="bUsable" type="number" min="0" placeholder="ระบุจำนวน usable"/></div>
          </div>
          <div class="card">
            <b>Dept C (≥10 hosts)</b>
            <div class="kv"><span class="badge">CIDR</span>
              <select id="cCidr"><option>/25</option><option>/26</option><option>/27</option><option>/28</option></select>
            </div>
            <div class="kv"><span class="badge">Usable</span><input id="cUsable" type="number" min="0" placeholder="ระบุจำนวน usable"/></div>
          </div>
        </div>
        <div class="kv"><button class="btn" id="checkA">ตรวจด่าน A</button> <span class="pill" id="msgA">ยังไม่ตรวจ</span></div>
        <small>เงื่อนไข: เลือก CIDR ให้พอรองรับ host, และเรียง “ใหญ่ไปเล็ก” เพื่อไม่ชนกัน (ตรรกะ VLSM)</small>
      </div>

      <!-- Stage B: Routing + ACL + Latency -->
      <div class="stage" id="sB">
        <h3>ด่าน B — เส้นทางปลอดภัยภายใต้ ACL / Latency</h3>
        <p>เลือกเส้นทางจาก <b>Client</b> ไป <b>WebSrv</b> ให้ผ่านได้จริงสำหรับพอร์ตที่เลือก และรวม Latency ≤ <b>25 ms</b></p>
        <div class="kv" role="radiogroup" aria-label="เลือกโปรโตคอล">
          <label><input type="radio" name="proto" value="80" checked/> HTTP : 80</label>
          <label style="margin-left:12px"><input type="radio" name="proto" value="443"/> HTTPS : 443</label>
        </div>
        <canvas id="netCanvas"></canvas>
        <div class="kv"><button class="btn" id="checkB">ตรวจด่าน B</button> <span class="pill" id="msgB">ยังไม่ตรวจ</span></div>
        <small>วิธีเล่น: คลิกเส้นเพื่อ “เลือก/ยกเลิก” ทางเชื่อม (เส้นจะเรืองแสงเมื่อถูกเลือก) บางเส้นมี ACL บล็อกพอร์ต</small>
      </div>

      <!-- Stage C: NAT Table -->
      <div class="stage" id="sC">
        <h3>ด่าน C — NAT Table ไม่ชนพอร์ต</h3>
        <p>กำหนดตาราง <b>Static PAT</b> สำหรับการเชื่อมต่อไป <b>WebSrv</b> ให้ครบและไม่ชนกัน</p>
        <table aria-label="NAT table">
          <thead><tr><th>Inside IP:Port</th><th>Outside IP</th><th>Outside Port</th><th>หมายเหตุ</th></tr></thead>
          <tbody id="natBody">
            <tr>
              <td><input value="192.168.10.10:80" readonly/></td>
              <td><input value="203.0.113.10" readonly/></td>
              <td><input type="number" class="outPort" placeholder="กรอกพอร์ต (≥1024)"/></td>
              <td>ClientA → Web (ต้องไม่ซ้ำ)</td>
            </tr>
            <tr>
              <td><input value="192.168.10.20:443" readonly/></td>
              <td><input value="203.0.113.10" readonly/></td>
              <td><input type="number" class="outPort" placeholder="กรอกพอร์ต (≥1024)"/></td>
              <td>ClientB → Web (ต้องไม่ซ้ำ)</td>
            </tr>
            <tr>
              <td><input value="192.168.10.30:443" readonly/></td>
              <td><input value="203.0.113.10" readonly/></td>
              <td><input type="number" class="outPort" placeholder="กรอกพอร์ต (≥1024)"/></td>
              <td>ClientC → Web (ต้องไม่ซ้ำ)</td>
            </tr>
          </tbody>
        </table>
        <div class="kv"><button class="btn" id="checkC">ตรวจด่าน C</button> <span class="pill" id="msgC">ยังไม่ตรวจ</span></div>
        <small>เงื่อนไข: พอร์ตภายนอก (Outside Port) ห้ามซ้ำกัน และต้องอยู่ในช่วงผู้ใช้ (≥1024)</small>
      </div>

      <!-- Finish -->
      <div class="card" id="finishCard" style="display:none; text-align:center; margin-top:12px">
        <h2>ผ่าน Hard Mode แล้ว! 🎉</h2>
        <p>โค้ดสำหรับ <b>Terminal-F3</b> คือ</p>
        <div class="kv" style="justify-content:center">
          <input id="secretCode" value="Computer" readonly
                 style="font-weight:900; font-size:18px; padding:10px 12px; border:3px solid #0001; border-radius:12px; width:200px; text-align:center; background:#f8fafc"/>
          <button class="btn ok" id="btnCopy">คัดลอก</button>
        </div>
      </div>
    </section>

    <!-- RIGHT: STATUS / HINT -->
    <aside class="card" aria-live="polite">
      <h3 style="margin-top:0">ข้อมูล & สถานะ</h3>
      <ul style="margin:8px 0 10px; padding-left:20px">
        <li>โหมด: <b>Hard</b> (VLSM • ACL+Latency • NAT)</li>
        <li>ใบ้อัตโนมัติทุก <b>60 วิ</b> หลังเริ่มเกม (ไม่สปอยล์)</li>
      </ul>

      <div class="card" style="background:#fff7ed; border-color:#fed7aa">
        <b>ตัวจับเวลาใบ้</b>
        <div class="kv" style="align-items:center">
          <div class="bar" style="flex:1"><span id="hintFill"></span></div>
          <span class="pill" id="hintCountdown">60s</span>
        </div>
        <small id="hintLevel">Hint Level: 0</small>
      </div>

      <div class="card" style="margin-top:12px">
        <h4 style="margin:6px 0">สถานะด่าน</h4>
        <span class="pill" id="pA">A: ❌</span>
        <span class="pill" id="pB">B: ❌</span>
        <span class="pill" id="pC">C: ❌</span>
      </div>
    </aside>
  </div>
</div>

<!-- Modals -->
<div class="backdrop" id="how">
  <div class="card" style="max-width:760px; width:min(95%,760px)">
    <h2 style="margin-top:0">สอนเล่น (ไม่สปอยล์)</h2>
    <ol style="padding-left:20px; line-height:1.6">
      <li><b>ด่าน A</b>: เลือก CIDR ให้พอกับจำนวนโฮสต์ และระบุจำนวน usable ที่ถูกต้อง (ตรรกะ VLSM)</li>
      <li><b>ด่าน B</b>: เลือกพอร์ต (HTTP/HTTPS) แล้วคลิกเส้นทางให้วิ่งจาก Client → WebSrv โดยไม่ติด ACL และ Latency รวมไม่เกินเงื่อนไข</li>
      <li><b>ด่าน C</b>: กำหนด Outside Port สำหรับ Static PAT ให้ไม่ซ้ำและ ≥ 1024</li>
    </ol>
    <div class="kv" style="justify-content:flex-end"><button class="btn" id="closeHow">ปิด</button></div>
  </div>
</div>

<div class="backdrop" id="hint">
  <div class="card" style="max-width:720px; width:min(95%,720px)">
    <h2 style="margin-top:0">คำใบ้</h2>
    <p id="hintText">…</p>
    <div class="kv" style="justify-content:flex-end"><button class="btn" id="closeHint">โอเค</button></div>
  </div>
</div>

<!-- Toast + Confetti -->
<div class="toast" id="toast">คัดลอกแล้ว!</div>
<canvas class="confetti" id="confetti"></canvas>

<script>
(()=>{
/* ====== Utilities (แก้ให้ $ ใช้ได้ทั้ง "#id"/".class" และ "id" ตรง ๆ) ====== */
function $(sel){
  if(!sel) return null;
  if(typeof sel !== "string") return sel;
  if(sel.startsWith("#") || sel.startsWith(".")) return document.querySelector(sel);
  // ถ้าไม่มี #/. ให้มองว่าเป็น id
  return document.getElementById(sel);
}

/* ====== State ====== */
const ST = { started:false, A:false, B:false, C:false, hintTick:60, hintLevel:0, hintTimer:null, selectedEdges:new Set(), proto:80 };

/* ====== Progress ====== */
function setProgress(){
  const n = (ST.A?1:0)+(ST.B?1:0)+(ST.C?1:0);
  $("progressText").textContent = n+"/3";
  $("barFill").style.width = (n/3*100)+"%";
  $("pA").textContent = "A: " + (ST.A?"✅":"❌");
  $("pB").textContent = "B: " + (ST.B?"✅":"❌");
  $("pC").textContent = "C: " + (ST.C?"✅":"❌");
  $("#sA").classList.toggle("done",ST.A);
  $("#sB").classList.toggle("done",ST.B);
  $("#sC").classList.toggle("done",ST.C);
  if(n===3) finish();
}

/* ====== Hints (non-spoiler) ====== */
const HINTS = [
  // A
  "A: เริ่มแบ่งเครือข่ายด้วยกลุ่มที่ต้องการโฮสต์มากที่สุดก่อน (VLSM หลักการใหญ่ไปเล็ก)",
  "A: /26 ≈ 62 usable, /27 ≈ 30 usable, /28 ≈ 14 usable — เทียบกับความต้องการแต่ละแผนก",
  // B
  "B: เส้นผ่าน Firewall อาจบล็อกบางพอร์ต เลือกพอร์ตให้เหมาะก่อนวางเส้น",
  "B: Latency รวมของเส้นทางต้องไม่เกินเงื่อนไข — เส้นที่ยาวเกินไปอาจไม่ผ่าน",
  // C
  "C: Static PAT ต้องไม่ซ้ำพอร์ตภายนอก และควรใช้พอร์ต ≥ 1024",
  "C: ตรวจว่าทุกแถวระบุพอร์ตครบและไม่ซ้ำ"
];

function showHint(){
  if(ST.hintLevel >= HINTS.length) return;
  $("#hintText").textContent = HINTS[ST.hintLevel++];
  $("#hintLevel").textContent = "Hint Level: " + ST.hintLevel;
  $("#hint").classList.add("show");
}
$("#closeHint").onclick = ()=> $("#hint").classList.remove("show");

function tickHint(reset=false){
  if(reset){
    ST.hintTick=60;
    $("#hintCountdown").textContent = "60s";
    $("#hintFill").style.width = "0%";
    return;
  }
  ST.hintTick--;
  $("#hintCountdown").textContent = ST.hintTick+"s";
  $("#hintFill").style.width = ((60-ST.hintTick)/60*100)+"%";
  if(ST.hintTick<=0){
    ST.hintTick=60;
    if(!(ST.A&&ST.B&&ST.C)) showHint();
    $("#hintCountdown").textContent = "60s";
    $("#hintFill").style.width = "0%";
  }
}

/* ====== Stage A (VLSM) ====== */
const usableOf = cidr=>{
  const n = parseInt(cidr.replace("/",""),10);
  const total = Math.pow(2, 32-n);
  return Math.max(total-2, 0);
};

$("#checkA").onclick = ()=>{
  const aC=$("#aCidr").value, bC=$("#bCidr").value, cC=$("#cCidr").value;
  const aU=Number($("#aUsable").value), bU=Number($("#bUsable").value), cU=Number($("#cUsable").value);
  const needA=60, needB=30, needC=10;
  const okU = (aU===usableOf(aC) && bU===usableOf(bC) && cU===usableOf(cC));
  const okNeed = (aU>=needA && bU>=needB && cU>=needC);
  // VLSM order: A ≥ B ≥ C (ในแง่ usable) -> CIDR A <= CIDR B <= CIDR C
  const toNum = c=>parseInt(c.replace("/",""),10);
  const orderOK = (toNum(aC)<=toNum(bC) && toNum(bC)<=toNum(cC));
  const all = okU && okNeed && orderOK;
  ST.A = all;
  $("#msgA").textContent = all ? "ถูกต้อง ✅" : "ยังไม่ผ่าน ❌";
  $("#msgA").style.background = all ? "#dcfce7" : "#fee2e2";
  setProgress();
};

/* ====== Stage B (Routing+ACL+Latency) ====== */
const canvas = $("#netCanvas");
const ctx = canvas.getContext("2d");
let DPR = window.devicePixelRatio||1;
let W,H;
const nodes = [
  {id:"C", x:120, y:160, r:26, label:"Client"},
  {id:"R1", x:350, y:90, r:24, label:"R1"},
  {id:"FW", x:350, y:230, r:24, label:"FW"},
  {id:"R2", x:580, y:90, r:24, label:"R2"},
  {id:"S", x:580, y:230, r:26, label:"WebSrv"}
];
// Edges with latency (ms) & ACL (allowed ports array or 'any')
const edges = [
  {id:"C-R1", a:"C", b:"R1", lat:8, acl:"any"},
  {id:"C-FW", a:"C", b:"FW", lat:14, acl:"any"},
  {id:"R1-R2", a:"R1", b:"R2", lat:10, acl:[80,443]},
  {id:"R1-FW", a:"R1", b:"FW", lat:7, acl:[443]},
  {id:"FW-S", a:"FW", b:"S", lat:6, acl:[443]},
  {id:"R2-S", a:"R2", b:"S", lat:9, acl:"any"}
];
function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  W = canvas.width = Math.max(320, rect.width) * DPR;
  H = canvas.height = Math.max(220, rect.height) * DPR;
  drawNet();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function N(id){ return nodes.find(n=>n.id===id); }

function drawNet(){
  ctx.clearRect(0,0,W,H);
  // draw edges
  edges.forEach(e=>{
    const A=N(e.a), B=N(e.b);
    const sel = ST.selectedEdges.has(e.id);
    ctx.beginPath();
    ctx.lineWidth = sel ? 6*DPR : 3*DPR;
    ctx.strokeStyle = sel ? "#22c55e" : "#94a3b8";
    ctx.moveTo(A.x*DPR, A.y*DPR); ctx.lineTo(B.x*DPR, B.y*DPR); ctx.stroke();
    // latency label
    const mx = (A.x+B.x)/2, my=(A.y+B.y)/2;
    ctx.fillStyle = "#111";
    ctx.font = (12*DPR)+"px sans-serif";
    ctx.fillText(`${e.lat}ms`, mx*DPR+6, my*DPR-6);
    // ACL dot
    ctx.beginPath(); ctx.arc(mx*DPR, my*DPR, 5*DPR, 0, Math.PI*2);
    ctx.fillStyle = e.acl==="any" ? "#16a34a" : "#f59e0b"; ctx.fill();
  });
  // draw nodes
  nodes.forEach(n=>{
    ctx.beginPath(); ctx.arc(n.x*DPR, n.y*DPR, n.r*DPR, 0, Math.PI*2);
    ctx.fillStyle = "#fff"; ctx.fill();
    ctx.lineWidth = 3*DPR; ctx.strokeStyle="#00000020"; ctx.stroke();
    ctx.fillStyle = "#111"; ctx.font = (12*DPR)+"px sans-serif";
    ctx.fillText(n.label, (n.x-20)*DPR, (n.y+n.r+14)*DPR);
  });
}

function distPointToSegment(px,py,ax,ay,bx,by){
  const A=[ax,ay], B=[bx,by], P=[px,py];
  const AB=[B[0]-A[0], B[1]-A[1]];
  const AP=[P[0]-A[0], P[1]-A[1]];
  const ab2 = AB[0]*AB[0]+AB[1]*AB[1];
  const dot = AP[0]*AB[0]+AP[1]*AB[1];
  const t = Math.max(0, Math.min(1, dot/ab2));
  const proj=[A[0]+AB[0]*t, A[1]+AB[1]*t];
  const dx=proj[0]-P[0], dy=proj[1]-P[1];
  return Math.sqrt(dx*dx+dy*dy);
}

canvas.addEventListener('click', ev=>{
  const rect = canvas.getBoundingClientRect();
  const x = (ev.clientX-rect.left)*DPR, y=(ev.clientY-rect.top)*DPR;
  // toggle nearest edge within threshold
  let toggled=false;
  for(const e of edges){
    const A=N(e.a), B=N(e.b);
    const d = distPointToSegment(x,y, A.x*DPR,A.y*DPR, B.x*DPR,B.y*DPR);
    if(d <= 10*DPR){
      if(ST.selectedEdges.has(e.id)) ST.selectedEdges.delete(e.id);
      else ST.selectedEdges.add(e.id);
      toggled=true; break;
    }
  }
  if(toggled) drawNet();
});

document.querySelectorAll('input[name="proto"]').forEach(r=>{
  r.addEventListener('change', ()=>{ ST.proto = Number(r.value); ST.selectedEdges.clear(); drawNet(); });
});

function pathValid(){
  // must form a connected path C -> ... -> S using selected edges, obey ACL & latency sum ≤ 25
  const allowedEdges = edges.filter(e=>{
    if(!ST.selectedEdges.has(e.id)) return false;
    if(e.acl==="any") return true;
    return e.acl.includes(ST.proto);
  });
  if(allowedEdges.length===0) return {ok:false, reason:"ไม่มีเส้นทาง"};
  // adjacency
  const adj = {};
  allowedEdges.forEach(e=>{
    (adj[e.a] ||= []).push({to:e.b,lat:e.lat});
    (adj[e.b] ||= []).push({to:e.a,lat:e.lat});
  });
  // DFS from C to S with latency sum
  const stack = [{id:"C",lat:0,vis:new Set(["C"])}];
  while(stack.length){
    const cur = stack.pop();
    if(cur.id==="S") return {ok: cur.lat <= 25, reason: cur.lat<=25 ? "ok" : "Latency เกิน"};
    const nexts = adj[cur.id] || [];
    for(const nx of nexts){
      if(cur.vis.has(nx.to)) continue;
      const newLat = cur.lat + nx.lat;
      if(newLat > 25) continue; // prune
      const vis2 = new Set(cur.vis); vis2.add(nx.to);
      stack.push({id:nx.to, lat:newLat, vis:vis2});
    }
  }
  return {ok:false, reason:"ไม่ถึงปลายทาง"};
}

$("#checkB").onclick = ()=>{
  const r = pathValid();
  const good = r.ok;
  ST.B = good;
  $("#msgB").textContent = good ? "ถูกต้อง ✅" : "ยังไม่ผ่าน ❌ ("+r.reason+")";
  $("#msgB").style.background = good ? "#dcfce7" : "#fee2e2";
  setProgress();
};

/* ====== Stage C (NAT) ====== */
$("#checkC").onclick = ()=>{
  const outs = Array.from(document.querySelectorAll(".outPort")).map(i=>Number(i.value));
  const allFilled = outs.every(v=>Number.isInteger(v) && v>=1024 && v<=65535);
  const unique = new Set(outs).size === outs.length;
  const ok = allFilled && unique;
  ST.C = ok;
  $("#msgC").textContent = ok ? "ถูกต้อง ✅" : "ยังไม่ผ่าน ❌ (ตรวจพอร์ต ≥1024 และไม่ซ้ำ)";
  $("#msgC").style.background = ok ? "#dcfce7" : "#fee2e2";
  setProgress();
};

/* ====== Finish / Confetti / Clipboard ====== */
function finish(){
  $("#finishCard").style.display = "block";
  burstConfetti();
}
$("#btnCopy").onclick = async ()=>{
  try{
    await navigator.clipboard.writeText($("#secretCode").value);
    const t=$("#toast"); t.textContent="คัดลอกแล้ว!"; t.classList.add("show");
    setTimeout(()=>t.classList.remove("show"),1200);
  }catch(e){ alert("คัดลอกไม่สำเร็จ: "+e); }
};

function burstConfetti(){
  const c=$("#confetti"), ctx=c.getContext("2d"), dpr=window.devicePixelRatio||1;
  const W=c.width=innerWidth*dpr, H=c.height=innerHeight*dpr;
  const pcs=Array.from({length:160},()=>({x:Math.random()*W,y:-20*dpr,r:4+Math.random()*8,vx:-1+Math.random()*2,vy:1+Math.random()*3,rot:Math.random()*Math.PI}));
  let frame=0;
  (function tick(){
    ctx.clearRect(0,0,W,H);
    pcs.forEach(p=>{
      p.x+=p.vx; p.y+=p.vy; p.rot+=0.08;
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      const colors=["#ff7aa2","#7adcf5","#ffd166","#22c55e"]; ctx.fillStyle=colors[(Math.random()*4)|0];
      ctx.fillRect(-p.r/2,-p.r/2,p.r,p.r*1.6); ctx.restore();
    });
    frame++; if(frame<220) requestAnimationFrame(tick);
  })();
}

/* ====== Controls ====== */
$("#btnStart").onclick = ()=>{
  if(!ST.started){
    ST.started=true;
    if(ST.hintTimer) clearInterval(ST.hintTimer);
    tickHint(true);
    ST.hintTimer=setInterval(()=>{ if(ST.started) tickHint(false); },1000);
  }
};
$("#btnHow").onclick = ()=> $("#how").classList.add("show");
$("#closeHow").onclick = ()=> $("#how").classList.remove("show");
$("#btnHintNow").onclick = ()=> showHint();
$("#btnReset").onclick = ()=>{
  // reset all
  ST.started=false; ST.A=ST.B=ST.C=false; ST.selectedEdges.clear(); ST.proto=80; setProgress();
  // Reset A
  $("#aCidr").value="/25"; $("#bCidr").value="/25"; $("#cCidr").value="/25";
  $("#aUsable").value=""; $("#bUsable").value=""; $("#cUsable").value="";
  $("#msgA").textContent="ยังไม่ตรวจ"; $("#msgA").style.background="";
  // Reset B
  document.querySelector('input[name="proto"][value="80"]').checked=true;
  $("#msgB").textContent="ยังไม่ตรวจ"; $("#msgB").style.background=""; drawNet();
  // Reset C
  document.querySelectorAll(".outPort").forEach(i=>i.value="");
  $("#msgC").textContent="ยังไม่ตรวจ"; $("#msgC").style.background="";
  // Finish panel
  $("#finishCard").style.display="none";
  // Hints
  ST.hintLevel=0; tickHint(true);
};
setProgress(); drawNet();
})();
</script>
</body>
</html>
